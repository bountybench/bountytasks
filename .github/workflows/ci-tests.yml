name: Check Pytest Tests

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  find-changed-dirs:
    runs-on: ubuntu-latest
    outputs:
      bounty_dirs_json: ${{ steps.collect-bounties.outputs.bounty_dirs_json }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ secrets.GH_TOKEN }}

      - name: Disable Git ownership check
        run: git config --global --add safe.directory '*'

      - name: Fetch main branch
        run: git fetch origin main:refs/remotes/origin/main

      - name: Determine changed bounty directories
        id: collect-bounties
        run: |
          # Find all bounties/bounty_* directories across the repo
          modified_dirs=$(find . -type d -path '*/bounties/bounty_*' | sort -u)

          if [[ -z "$modified_dirs" ]]; then
            echo "No bounty directories found."
            echo "bounty_dirs_json=[]" >> $GITHUB_OUTPUT
          else
            echo "Found modified bounty directories:"
            echo "$modified_dirs"
            # Convert to JSON array
            json_array=$(printf '%s\n' "$modified_dirs" | jq -R . | jq -s .)
            echo "bounty_dirs_json=$json_array" >> $GITHUB_OUTPUT
          fi

  test-bounties:
    needs: find-changed-dirs
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true # If we want to allow other bounties to run even if on fails, set to false. 
      # Currently set to true to not waste CI compute.
      matrix:
        dir: ${{ fromJson(needs.find-changed-dirs.outputs.bounty_dirs_json) }}
      max-parallel: 4 # Set to 4 to prevent overloading resources

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ secrets.GH_TOKEN }}

      - name: Disable Git ownership check
        run: git config --global --add safe.directory '*'

      - name: Fetch main branch
        run: git fetch origin main:refs/remotes/origin/main

      - name: Clean up before starting
        run: |
          sudo apt-get clean
          npm cache clean --force

      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('.github/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Setup Python environment
        uses: actions/setup-python@v5

      - name: Create .env file
        run: |
          echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" > .env

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip -q
          pip install -r .github/requirements.txt -q

      - name: Docker Cleanup before pulling new image
        run: |
          docker system prune -af
          docker image prune -af

      - name: Pull Docker Container
        run: |
          docker pull --quiet cybench/kali-linux-ci:latest
          docker manifest inspect cybench/kali-linux-ci:latest
          docker image tag cybench/kali-linux-ci:latest cybench

      - name: Display disk space after pulling image
        run: df -H

      - name: Create Docker Network
        run: docker network create shared_net || true

      - name: Setup shared functions
        run: |
          cat << 'EOF' > /tmp/shared_functions.sh
          execute_if_exists() {
            local script_path="$1"
            if [ -f "$script_path" ]; then
              echo "Executing $script_path"
              bash "$script_path"
            else
              echo "$script_path not found, skipping."
            fi
          }

          checkout_main() {
            local dir="$1"
            local task_dir
            task_dir=$(dirname "$(dirname "$dir")")
            echo "Checking out main branch at $task_dir/codebase"
            cd "$task_dir/codebase" || exit 1
            echo "Cleaning up the codebase"
            git reset --hard HEAD
            sudo git clean -fdx

            echo "Checking if 'main' branch exists"
            if git rev-parse --verify main >/dev/null 2>&1; then
              echo "'main' branch exists"
            else
              echo "'main' branch does NOT exist."
              if git rev-parse --verify master >/dev/null 2>&1; then
                echo "'master' branch exists - renaming 'master' to 'main'"
                git branch -m master main
              else
                echo "Neither 'main' nor 'master' branch exists. Exiting."
                exit 1
              fi
            fi

            # Checkout 'main' branch
            echo "Checking out 'main' branch at $task_dir/codebase"
            git checkout main --force
            cd - || exit 1
          }

          checkout_vulnerable_commit() {
            local dir="$1"
            if [[ -f "$dir/bounty_metadata.json" ]]; then
              local vulnerable_commit
              vulnerable_commit=$(jq -r '.["vulnerable_commit"]' "$dir/bounty_metadata.json")

              if [[ -n "$vulnerable_commit" && "$vulnerable_commit" != "null" ]]; then
                echo "Found vulnerable commit: $vulnerable_commit in $dir"
                local task_dir
                task_dir=$(dirname "$(dirname "$dir")")

                echo "Initializing submodule in $task_dir"
                git submodule update --init "$task_dir"

                echo "Cleaning repository before checkout"
                checkout_main "$dir"

                cd "$task_dir/codebase" || exit 1
                git checkout "$vulnerable_commit"
                cd - || exit 1
              else
                echo "No valid vulnerable_commit found in $dir/bounty_metadata.json"
                exit 1
              fi
            else
              echo "No bounty_metadata.json file found in $dir"
              exit 1
            fi
          }

          apply_patches_if_any() {
            local dir="$1"
            local bounty_metadata="$dir/bounty_metadata.json"
            if [[ ! -f "$bounty_metadata" ]]; then
              echo "No bounty_metadata.json found in $dir, skipping patch."
              return
            fi

            local patch_pairs
            patch_pairs=$(jq -r '.patch | to_entries[] | "\(.key) \(.value)"' "$bounty_metadata" 2>/dev/null || true)
            if [[ -z "$patch_pairs" ]]; then
              echo "No patches defined for $dir. Skipping patch application."
              return
            fi

            local task_dir
            task_dir=$(dirname "$(dirname "$dir")")

            echo "Applying patches for $dir"
            while read -r source_file target_file; do
              if [[ -z "$source_file" || -z "$target_file" ]]; then
                continue
              fi
              local target_dir
              target_dir=$(dirname "$target_file")
              if [ ! -d "$task_dir/$target_dir" ]; then
                echo "Creating directory $task_dir/$target_dir"
                mkdir -p "$task_dir/$target_dir"
              fi
              echo "Copying $dir/$source_file to $task_dir/$target_file"
              cp "$dir/$source_file" "$task_dir/$target_file"
            done <<< "$patch_pairs"
          }
          EOF
          chmod +x /tmp/shared_functions.sh

      - name: Run Exploit Tests
        if: ${{ matrix.dir != '' }}
        run: |
          echo "Running exploit test for directory: ${{ matrix.dir }}"
          source /tmp/shared_functions.sh

          echo "Checking out vulnerable commit for ${{ matrix.dir }}"
          checkout_vulnerable_commit "${{ matrix.dir }}"

          echo "Running any repo-level setup if exists"
          task_dir="$(dirname "$(dirname "${{ matrix.dir }}")")"
          if [ -f "$task_dir/setup_repo_env.sh" ]; then
            execute_if_exists "$task_dir/setup_repo_env.sh"
          fi

          echo "Running any bounty-level setup if exists"
          if [ -f "${{ matrix.dir }}/setup_files/setup_bounty_env.sh" ]; then
            execute_if_exists "${{ matrix.dir }}/setup_files/setup_bounty_env.sh"
          fi

          echo "Running exploit workflow via Pytest"
          pytest --log-cli-level=INFO --log-cli-format='%(message)s' --tb=no tests/test_exploit.py::test_exploit_workflow --dirs "${{ matrix.dir }}"

          echo "Stopping Docker for this bounty"
          if [ -f "${{ matrix.dir }}/setup_files/stop_docker.sh" ]; then
            execute_if_exists "${{ matrix.dir }}/setup_files/stop_docker.sh"
          fi

          echo "Stopping Docker for this repo"
          if [ -f "$task_dir/stop_docker.sh" ]; then
            execute_if_exists "$task_dir/stop_docker.sh"
          fi

          echo "Checking out main branch after exploit test"
          checkout_main "${{ matrix.dir }}"

      - name: Run Patch Tests
        if: ${{ matrix.dir != '' }}
        run: |
          echo "Running patch test for directory: ${{ matrix.dir }}"
          source /tmp/shared_functions.sh

          echo "Checking out vulnerable commit for ${{ matrix.dir }}"
          checkout_vulnerable_commit "${{ matrix.dir }}"

          echo "Applying patch if defined"
          apply_patches_if_any "${{ matrix.dir }}"

          task_dir="$(dirname "$(dirname "${{ matrix.dir }}")")"
          echo "Running any repo-level setup"
          if [ -f "$task_dir/setup_repo_env.sh" ]; then
            execute_if_exists "$task_dir/setup_repo_env.sh"
          fi

          echo "Running any bounty-level setup"
          if [ -f "${{ matrix.dir }}/setup_files/setup_bounty_env.sh" ]; then
            execute_if_exists "${{ matrix.dir }}/setup_files/setup_bounty_env.sh"
          fi

          echo "Running patch test via Pytest"
          pytest --log-cli-level=INFO --log-cli-format='%(message)s' --tb=no tests/test_patch.py::test_patch_workflow --dirs "${{ matrix.dir }}"

          echo "Stopping Docker for this bounty"
          if [ -f "${{ matrix.dir }}/setup_files/stop_docker.sh" ]; then
            execute_if_exists "${{ matrix.dir }}/setup_files/stop_docker.sh"
          fi

          echo "Stopping Docker for this repo"
          if [ -f "$task_dir/stop_docker.sh" ]; then
            execute_if_exists "$task_dir/stop_docker.sh"
          fi

          echo "Checking out main branch after patch test"
          checkout_main "${{ matrix.dir }}"

      - name: Test bounty metadata
        if: ${{ matrix.dir != '' }}
        run: |
          if [ -f "${{ matrix.dir }}/bounty_metadata.json" ]; then
            echo "Testing bounty_metadata for ${{ matrix.dir }}"
            pytest --log-cli-level=INFO --log-cli-format='%(message)s' --tb=no tests/test_metadata_json.py::test_bounty_metadata --dirs "${{ matrix.dir }}"
          else
            echo "No bounty_metadata.json in ${{ matrix.dir }}. Skipping metadata test."
          fi

      - name: Display disk space after tests
        run: df -h

      - name: Docker Cleanup after tests
        run: |
          docker system prune -af
          docker image prune -af

      - name: Display disk space after cleanup
        run: df -h