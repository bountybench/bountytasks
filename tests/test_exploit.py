# tests/test_exploit.py
import pytest
from tests.docker_helper import DockerHelper
from tests.logger import logger, ERROR
from tests.util import run_exploit_script, run_verify_script

def pytest_addoption(parser):
    """
    This hook adds a custom --dirs command-line option to pytest,
    enabling us to pass in multiple directories if desired.
    """
    parser.addoption(
        "--dirs",
        action="append",
        default=[],
        help="List of bounty directories to test."
    )

def pytest_generate_tests(metafunc):
    """
    Dynamically parametrize 'dir_path' based on --dirs input.
    If user passes: pytest --dirs bounties/bounty_123 --dirs bounties/bounty_456
    Then we get 2 tests: test_exploit_workflow[bounties/bounty_123], test_exploit_workflow[bounties/bounty_456]
    """
    if "dir_path" in metafunc.fixturenames:
        dirs = []
        for d in metafunc.config.getoption("dirs"):
            # If someone passes space-separated or a single string, handle that:
            dirs.extend(d.strip().split())
        if dirs:
            metafunc.parametrize("dir_path", dirs, ids=dirs)

@pytest.fixture(scope="session")
def docker_helper():
    # We can keep it session-scoped if the DockerHelper is okay being reused across tests
    return DockerHelper()

def exploit_workflow(path, docker_helper):
    logger.info(f"Running exploit workflow for {path}")

    logger.info(
        f"Running verify script for {path} before executing the exploit to confirm verify fails when exploit has not been run")
    verify_result = run_verify_script(path)
    if verify_result != 1:
        logger.error(ERROR)
        logger.error(
            f"Verify script succeeded for {path} before exploit execution.\n"
            f"Verify should return with exit code 1 but returned {verify_result}."
        )
        pytest.fail(f"Verify script succeeded for {path} before exploit execution.")
    else:
        logger.info(f"Verify fails with exit code {verify_result} as expected.")

    logger.info(f"Running exploit for {path}")
    run_exploit_script(path, docker_helper)

    logger.info(
        f"Running verify script for {path} after executing the exploit. Verify should succeed.")
    verify_result = run_verify_script(path)
    if verify_result != 0:
        logger.error(ERROR)
        logger.error(
            f"Verify script failed for {path} after exploit execution.\n"
            f"Verify should return with exit code 0 but returned {verify_result}."
        )
        pytest.fail(f"Verify script failed for {path} after exploit execution.")
    else:
        logger.info(f"Verify suceeds with exit code {verify_result} as expected.")


@pytest.mark.usefixtures("docker_helper")
def test_exploit_workflow(dir_path, docker_helper):
    """
    Each 'dir_path' is tested as a separate test case by Pytest.
    """
    exploit_workflow(dir_path, docker_helper)
